"""
BMOS系统 - API端点测试套件
提供完整的API端点测试覆盖
"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from fastapi.testclient import TestClient
from typing import Dict, Any, List
from datetime import datetime
import json

# 导入被测试的模块
from src.api.endpoints import (
    optimization, monitoring, tasks, models, 
    predictions, memories, data_import
)
from src.security.auth import User, Permission
from src.tasks.task_queue import Task, TaskStatus, TaskPriority

class TestOptimizationEndpoints:
    """优化建议端点测试"""
    
    @pytest.fixture
    def mock_user(self):
        """模拟用户"""
        return User(
            user_id="test_user_123",
            username="testuser",
            email="test@example.com",
            tenant_id="tenant_123",
            role="manager",
            permissions=[Permission.WRITE_OPTIMIZATION, Permission.READ_OPTIMIZATION]
        )
    
    @pytest.fixture
    def optimization_request_data(self):
        """优化建议请求数据"""
        return {
            "recommendation_type": "performance",
            "title": "提升生产效率",
            "description": "通过优化资源配置提升生产效率",
            "priority": "high",
            "impact_score": 8.5,
            "implementation_effort": "medium",
            "expected_roi": 1.5
        }
    
    @pytest.mark.asyncio
    async def test_create_optimization_success(self, mock_user, optimization_request_data):
        """测试创建优化建议成功"""
        with patch('backend.src.api.endpoints.optimization.get_db') as mock_db:
            # 模拟数据库操作
            mock_db.return_value.execute.return_value.fetchone.return_value = [123]
            
            with patch('backend.src.api.endpoints.optimization.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                # 测试创建优化建议
                result = await optimization.create_optimization(
                    optimization_data=optimization_request_data,
                    current_user=mock_user,
                    db=mock_db.return_value
                )
                
                assert result.id == 123
                assert result.title == optimization_request_data["title"]
                assert result.tenant_id == mock_user.tenant_id
                assert result.status == "pending"
    
    @pytest.mark.asyncio
    async def test_create_optimization_empty_title(self, mock_user):
        """测试创建优化建议 - 空标题"""
        invalid_data = {
            "recommendation_type": "performance",
            "title": "",  # 空标题
            "description": "测试描述",
            "priority": "medium"
        }
        
        with patch('backend.src.api.endpoints.optimization.require_permission') as mock_auth:
            mock_auth.return_value = mock_user
            
            with pytest.raises(Exception):  # 应该抛出异常
                await optimization.create_optimization(
                    optimization_data=invalid_data,
                    current_user=mock_user,
                    db=Mock()
                )
    
    @pytest.mark.asyncio
    async def test_get_optimizations_success(self, mock_user):
        """测试获取优化建议列表成功"""
        with patch('backend.src.api.endpoints.optimization.get_db') as mock_db:
            # 模拟数据库查询结果
            mock_rows = [
                (1, "uuid1", "tenant_123", "performance", "测试建议1", "描述1", 
                 "high", 8.5, "medium", 1.5, "pending", datetime.now(), datetime.now()),
                (2, "uuid2", "tenant_123", "security", "测试建议2", "描述2", 
                 "medium", 7.0, "low", 1.2, "completed", datetime.now(), datetime.now())
            ]
            mock_db.return_value.execute.return_value.fetchall.return_value = mock_rows
            
            with patch('backend.src.api.endpoints.optimization.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                result = await optimization.get_optimizations(
                    current_user=mock_user,
                    db=mock_db.return_value,
                    limit=10,
                    offset=0
                )
                
                assert len(result) == 2
                assert result[0].title == "测试建议1"
                assert result[1].title == "测试建议2"
    
    @pytest.mark.asyncio
    async def test_get_optimization_by_id_success(self, mock_user):
        """测试根据ID获取优化建议成功"""
        with patch('backend.src.api.endpoints.optimization.get_db') as mock_db:
            # 模拟数据库查询结果
            mock_row = (1, "uuid1", "tenant_123", "performance", "测试建议", "描述", 
                       "high", 8.5, "medium", 1.5, "pending", datetime.now(), datetime.now())
            mock_db.return_value.execute.return_value.fetchone.return_value = mock_row
            
            with patch('backend.src.api.endpoints.optimization.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                result = await optimization.get_optimization(
                    recommendation_id="uuid1",
                    current_user=mock_user,
                    db=mock_db.return_value
                )
                
                assert result.title == "测试建议"
                assert result.tenant_id == mock_user.tenant_id
    
    @pytest.mark.asyncio
    async def test_get_optimization_not_found(self, mock_user):
        """测试获取不存在的优化建议"""
        with patch('backend.src.api.endpoints.optimization.get_db') as mock_db:
            # 模拟数据库查询无结果
            mock_db.return_value.execute.return_value.fetchone.return_value = None
            
            with patch('backend.src.api.endpoints.optimization.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                with pytest.raises(Exception):  # 应该抛出404异常
                    await optimization.get_optimization(
                        recommendation_id="nonexistent",
                        current_user=mock_user,
                        db=mock_db.return_value
                    )

class TestMonitoringEndpoints:
    """系统监控端点测试"""
    
    @pytest.fixture
    def mock_user(self):
        """模拟用户"""
        return User(
            user_id="test_user_123",
            username="testuser",
            email="test@example.com",
            tenant_id="tenant_123",
            role="analyst",
            permissions=[Permission.READ_DATA]
        )
    
    @pytest.mark.asyncio
    async def test_get_monitoring_data_success(self, mock_user):
        """测试获取监控数据成功"""
        with patch('backend.src.api.endpoints.monitoring.get_db') as mock_db:
            # 模拟数据库查询结果
            mock_rows = [
                (1, "tenant_123", "model_1", "accuracy", 0.85, datetime.now(), 
                 0.8, True, "Accuracy below threshold", datetime.now()),
                (2, "tenant_123", "model_2", "latency", 120.5, datetime.now(), 
                 100.0, True, "Latency above threshold", datetime.now())
            ]
            mock_db.return_value.execute.return_value.fetchall.return_value = mock_rows
            
            with patch('backend.src.api.endpoints.monitoring.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                result = await monitoring.get_monitoring_data(
                    current_user=mock_user,
                    db=mock_db.return_value,
                    hours=24
                )
                
                assert len(result) == 2
                assert result[0].metric_name == "accuracy"
                assert result[1].metric_name == "latency"
    
    @pytest.mark.asyncio
    async def test_get_system_health_success(self, mock_user):
        """测试获取系统健康状态成功"""
        with patch('backend.src.api.endpoints.monitoring.get_db') as mock_db:
            # 模拟数据库连接正常
            mock_db.return_value.execute.return_value.fetchone.return_value = [5]  # 5个活跃模型
            
            with patch('backend.src.api.endpoints.monitoring.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                with patch('backend.src.api.endpoints.monitoring.psutil') as mock_psutil:
                    # 模拟系统资源使用情况
                    mock_psutil.cpu_percent.return_value = 35.2
                    mock_psutil.virtual_memory.return_value = Mock(percent=60.1, available=8*1024**3)
                    mock_psutil.disk_usage.return_value = Mock(percent=45.3, free=120*1024**3)
                    
                    result = await monitoring.get_system_health(
                        current_user=mock_user,
                        db=mock_db.return_value
                    )
                    
                    assert result["status"] == "healthy"
                    assert result["services"]["database"] == "healthy"
                    assert result["services"]["models"] == "healthy (5 active)"
                    assert result["resources"]["cpu_percent"] == 35.2
    
    @pytest.mark.asyncio
    async def test_get_performance_metrics_success(self, mock_user):
        """测试获取性能指标成功"""
        with patch('backend.src.api.endpoints.monitoring.get_db') as mock_db:
            # 模拟多个查询结果
            mock_db.return_value.execute.return_value.fetchone.side_effect = [
                [15, 0.8523, 45.6],  # 训练统计
                [1200, 0.125, 0.8934],  # 预测统计
                [8, 50000, 12.3],  # 导入统计
                [3500, 25, 45.2],  # API调用统计
                [5],  # 活跃模型数量
                [0.92, 10]  # 数据质量统计
            ]
            
            with patch('backend.src.api.endpoints.monitoring.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                result = await monitoring.get_performance_metrics(
                    current_user=mock_user,
                    db=mock_db.return_value,
                    hours=24
                )
                
                assert result["model_training"]["total_trainings"] == 15
                assert result["predictions"]["total_predictions"] == 1200
                assert result["data_import"]["total_records"] == 50000
                assert result["api_calls"]["total_calls"] == 3500
                assert result["active_models"] == 5
                assert result["data_quality"]["average_score"] == 0.92

class TestTasksEndpoints:
    """任务管理端点测试"""
    
    @pytest.fixture
    def mock_user(self):
        """模拟用户"""
        return User(
            user_id="test_user_123",
            username="testuser",
            email="test@example.com",
            tenant_id="tenant_123",
            role="admin",
            permissions=[Permission.TASK_CREATE, Permission.TASK_READ, Permission.TASK_DELETE]
        )
    
    @pytest.fixture
    def mock_task(self):
        """模拟任务"""
        return Task(
            task_id="task_123",
            task_name="test_task",
            queue_name="default",
            status=TaskStatus.PENDING,
            priority=TaskPriority.NORMAL,
            tenant_id="tenant_123",
            created_at=datetime.now(),
            retry_count=0,
            max_retries=3,
            task_data={"test": "data"}
        )
    
    @pytest.mark.asyncio
    async def test_get_all_tasks_success(self, mock_user, mock_task):
        """测试获取所有任务成功"""
        with patch('backend.src.api.endpoints.tasks.get_task_manager') as mock_task_manager:
            # 模拟任务管理器
            mock_task_manager.return_value.get_all_tasks.return_value = [mock_task]
            
            with patch('backend.src.api.endpoints.tasks.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                result = await tasks.get_all_tasks(
                    current_user=mock_user,
                    task_manager=mock_task_manager.return_value,
                    limit=10,
                    offset=0
                )
                
                assert len(result) == 1
                assert result[0].task_id == "task_123"
                assert result[0].task_name == "test_task"
                assert result[0].tenant_id == mock_user.tenant_id
    
    @pytest.mark.asyncio
    async def test_cancel_task_success(self, mock_user, mock_task):
        """测试取消任务成功"""
        with patch('backend.src.api.endpoints.tasks.get_task_manager') as mock_task_manager:
            # 模拟任务管理器
            mock_task_manager.return_value.get_task.return_value = mock_task
            mock_task_manager.return_value.cancel_task.return_value = True
            
            with patch('backend.src.api.endpoints.tasks.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                result = await tasks.cancel_task(
                    task_id="task_123",
                    current_user=mock_user,
                    task_manager=mock_task_manager.return_value
                )
                
                assert result["message"] == "任务已取消"
    
    @pytest.mark.asyncio
    async def test_cancel_task_not_found(self, mock_user):
        """测试取消不存在的任务"""
        with patch('backend.src.api.endpoints.tasks.get_task_manager') as mock_task_manager:
            # 模拟任务不存在
            mock_task_manager.return_value.get_task.return_value = None
            
            with patch('backend.src.api.endpoints.tasks.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                with pytest.raises(Exception):  # 应该抛出404异常
                    await tasks.cancel_task(
                        task_id="nonexistent",
                        current_user=mock_user,
                        task_manager=mock_task_manager.return_value
                    )
    
    @pytest.mark.asyncio
    async def test_cancel_task_wrong_tenant(self, mock_user):
        """测试取消其他租户的任务"""
        # 创建其他租户的任务
        other_tenant_task = Task(
            task_id="task_456",
            task_name="other_task",
            queue_name="default",
            status=TaskStatus.PENDING,
            priority=TaskPriority.NORMAL,
            tenant_id="other_tenant",  # 不同的租户
            created_at=datetime.now(),
            retry_count=0,
            max_retries=3,
            task_data={"test": "data"}
        )
        
        with patch('backend.src.api.endpoints.tasks.get_task_manager') as mock_task_manager:
            mock_task_manager.return_value.get_task.return_value = other_tenant_task
            
            with patch('backend.src.api.endpoints.tasks.require_permission') as mock_auth:
                mock_auth.return_value = mock_user
                
                with pytest.raises(Exception):  # 应该抛出403异常
                    await tasks.cancel_task(
                        task_id="task_456",
                        current_user=mock_user,
                        task_manager=mock_task_manager.return_value
                    )

class TestIntegrationScenarios:
    """集成测试场景"""
    
    @pytest.mark.asyncio
    async def test_complete_optimization_workflow(self):
        """测试完整的优化建议工作流"""
        # 1. 创建优化建议
        # 2. 获取优化建议列表
        # 3. 获取单个优化建议详情
        # 4. 系统监控检查
        
        mock_user = User(
            user_id="test_user_123",
            username="testuser",
            email="test@example.com",
            tenant_id="tenant_123",
            role="manager",
            permissions=[Permission.WRITE_OPTIMIZATION, Permission.READ_OPTIMIZATION, Permission.READ_DATA]
        )
        
        # 这里可以实现完整的集成测试
        # 由于需要真实的数据库连接，这里只是示例框架
        assert True  # 占位符
    
    @pytest.mark.asyncio
    async def test_task_lifecycle_workflow(self):
        """测试任务生命周期工作流"""
        # 1. 创建任务
        # 2. 获取任务状态
        # 3. 取消任务
        # 4. 获取任务统计
        
        mock_user = User(
            user_id="test_user_123",
            username="testuser",
            email="test@example.com",
            tenant_id="tenant_123",
            role="admin",
            permissions=[Permission.TASK_CREATE, Permission.TASK_READ, Permission.TASK_DELETE]
        )
        
        # 这里可以实现完整的任务生命周期测试
        assert True  # 占位符

# 测试配置
@pytest.fixture(scope="session")
def event_loop():
    """创建事件循环"""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()

# 运行测试的命令
# pytest backend/tests/test_api_endpoints.py -v
